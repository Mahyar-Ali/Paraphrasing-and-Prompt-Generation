# -*- coding: utf-8 -*-
"""Answer_Paraphrasing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wlPvKvWlT-wYmq0P9qQhP2V-tuX0clC0

##Paraphrasing using T5, finetuned using PAWS dataset
"""

!pip install transformers

!pip install sentencepiece

from transformers import AutoTokenizer, AutoModelForSeq2SeqLM

model_name= 'Vamsi/T5_Paraphrase_Paws'
tokenizer = AutoTokenizer.from_pretrained(model_name)

model = AutoModelForSeq2SeqLM.from_pretrained(model_name).to('cuda')

paraphrase = 'Why would you like my email address?'

text = 'paraphrase:' + paraphrase + '</s>'

encoding = tokenizer.encode_plus(text,pad_to_max_length=True, return_tensors="pt")

input_ids, attention_masks = encoding["input_ids"].to("cuda"), encoding["attention_mask"].to("cuda")

outputs = model.generate(
    input_ids=input_ids, attention_mask=attention_masks,
    max_length=256,
    do_sample=True,
    top_k=120,
    top_p=0.95,
    early_stopping=True,
    num_return_sequences=5
)

for output in outputs:
    line = tokenizer.decode(output, skip_special_tokens=True,clean_up_tokenization_spaces=True)
    print(line)

#running this without the question mark produces slightly different results.

for output in outputs:
    line = tokenizer.decode(output, skip_special_tokens=True,clean_up_tokenization_spaces=True)
    print(line)

# starting a chain; input: Why do you want to keep my email address?

for output in outputs:    
  line = tokenizer.decode(output, skip_special_tokens=True,clean_up_tokenization_spaces=True)    
  print(line)

#Why would you like my email address?
for output in outputs:      
  line = tokenizer.decode(output, skip_special_tokens=True,clean_up_tokenization_spaces=True)      
  print(line)

# Although the results are not like what one would have expected but still using chain, i.e., the outputs from one
# example answer as input to the next, have generated a few new sentences(at least one sentence for one type of input) 
# with the same intent

"""## More General version of T-5 finetuned on Quora Question Answer Pairs Dataset. [To DO! Implementation not complete yet]"""

!pip install pytorch-lightning

!pip install streamlit

!pip install --upgrade tensorflow

import torch

import argparse
import glob
import os
import json
import time
import logging
import random
import re
from itertools import chain
from string import punctuation

import nltk
nltk.download('punkt')
from nltk.tokenize import sent_tokenize

import pandas as pd
import numpy as np
import torch
from torch.utils.data import Dataset, DataLoader
import pytorch_lightning as pl


from transformers import AdamW, T5ForConditionalGeneration, T5Tokenizer, get_linear_schedule_with_warmup

def set_seed(seed):
  random.seed(seed)
  np.random.seed(seed)
  torch.manual_seed(seed)
  if torch.cuda.is_available():
    torch.cuda.manual_seed_all(seed)

set_seed(42)

class T5FineTuner(pl.LightningModule):

  def __init__(self,hparams):

    # Calling the super constructer
    super(T5FineTuner,self).__init__()

    self.hparams = hparams

    self.model = T5ForConditionalGeneration.from_pretrained(hparams.model_name_or_path)
    self.tokenizer = T5Tokenizer.from_pretrained(hparams.tokenizer_name_or_path)


  def forward(self, input_ids, attention_mask=None, decoder_input_ids=None, decoder_attention_mask=None, lm_labels=None):

    return self.model(input_ids, attention_mask=attention_mask,
            decoder_input_ids=decoder_input_ids,
            decoder_attention_mask=decoder_attention_mask,
            lm_labels=lm_labels,)
    
  def is_logger(self):
      return self.trainer.proc_rank <= 0
    

  def _step(self, batch):
        lm_labels = batch["target_ids"]
        lm_labels[lm_labels[:, :] == self.tokenizer.pad_token_id] = -100

        outputs = self(
            input_ids=batch["source_ids"],
            attention_mask=batch["source_mask"],
            lm_labels=lm_labels,
            decoder_attention_mask=batch['target_mask']
        )

        loss = outputs[0]

        return loss

  def training_step(self, batch, batch_idx):
      loss = self._step(batch)

      tensorboard_logs = {"train_loss": loss}
      return {"loss": loss, "log": tensorboard_logs}


  def training_epoch_end(self, outputs):
      avg_train_loss = torch.stack([x["loss"] for x in outputs]).mean()
      tensorboard_logs = {"avg_train_loss": avg_train_loss}
      return {"avg_train_loss": avg_train_loss, "log": tensorboard_logs, 'progress_bar': tensorboard_logs}

  def validation_step(self, batch, batch_idx):
      loss = self._step(batch)
      return {"val_loss": loss}

  def validation_epoch_end(self, outputs):
      avg_loss = torch.stack([x["val_loss"] for x in outputs]).mean()
      tensorboard_logs = {"val_loss": avg_loss}
      return {"avg_val_loss": avg_loss, "log": tensorboard_logs, 'progress_bar': tensorboard_logs}


  def configure_optimizers(self):
    "Prepare optimizer and schedule (linear warmup and decay)"

    model = self.model
    no_decay = ["bias", "LayerNorm.weight"]
    optimizer_grouped_parameters = [
        {
            "params": [p for n, p in model.named_parameters() if not any(nd in n for nd in no_decay)],
            "weight_decay": self.hparams.weight_decay,
        },
        {
            "params": [p for n, p in model.named_parameters() if any(nd in n for nd in no_decay)],
            "weight_decay": 0.0,
        },
    ]
    optimizer = AdamW(optimizer_grouped_parameters, lr=self.hparams.learning_rate, eps=self.hparams.adam_epsilon)
    self.opt = optimizer
    return [optimizer]


  def optimizer_step(self, epoch, batch_idx, optimizer, optimizer_idx, second_order_closure=None, using_native_amp=None):
    if self.trainer.use_tpu:
        xm.optimizer_step(optimizer)
    else:
        optimizer.step()
    optimizer.zero_grad()
    self.lr_scheduler.step()


  def get_tqdm_dict(self):
    tqdm_dict = {"loss": "{:.3f}".format(self.trainer.avg_loss), "lr": self.lr_scheduler.get_last_lr()[-1]}

    return tqdm_dict

  def train_dataloader(self):
    train_dataset = CustomDataset(tokenizer=self.tokenizer, type_path="PAW_Train_Global",data_dir=self.hparams.data_dir, max_len=self.hparams.max_seq_length)
    dataloader = DataLoader(train_dataset, batch_size=self.hparams.train_batch_size, drop_last=True, shuffle=True,
                            num_workers=4)
    t_total = (
            (len(dataloader.dataset) // (self.hparams.train_batch_size * max(1, self.hparams.n_gpu)))
            // self.hparams.gradient_accumulation_steps
            * float(self.hparams.num_train_epochs)
    )
    scheduler = get_linear_schedule_with_warmup(
        self.opt, num_warmup_steps=self.hparams.warmup_steps, num_training_steps=t_total
    )
    self.lr_scheduler = scheduler
    return dataloader

  def val_dataloader(self):
    val_dataset = CustomDataset(tokenizer=self.tokenizer, type_path="PAW_Test_Global",data_dir=self.hparams.data_dir, max_len=self.hparams.max_seq_length)
    return DataLoader(val_dataset, batch_size=self.hparams.eval_batch_size, num_workers=4)

logger = logging.getLogger(__name__)

class LoggingCallback(pl.Callback):
  def on_validation_end(self, trainer, pl_module):
    logger.info("***** Validation results *****")
    if pl_module.is_logger():
      metrics = trainer.callback_metrics
      # Log results
      for key in sorted(metrics):
        if key not in ["log", "progress_bar"]:
          logger.info("{} = {}\n".format(key, str(metrics[key])))

  def on_test_end(self, trainer, pl_module):
    logger.info("***** Test results *****")

    if pl_module.is_logger():
      metrics = trainer.callback_metrics

      # Log and save results to file
      output_test_results_file = os.path.join(pl_module.hparams.output_dir, "test_results.txt")
      with open(output_test_results_file, "w") as writer:
        for key in sorted(metrics):
          if key not in ["log", "progress_bar"]:
            logger.info("{} = {}\n".format(key, str(metrics[key])))
            writer.write("{} = {}\n".format(key, str(metrics[key])))

# Hyper parameters
args_dict = dict(
    data_dir="", # path for data files
    output_dir="", # path to save the checkpoints
    model_name_or_path='t5-base',
    tokenizer_name_or_path='t5-base',
    max_seq_length=512,
    learning_rate=3e-4,
    weight_decay=0.0,
    adam_epsilon=1e-8,
    warmup_steps=0,
    train_batch_size=6,
    eval_batch_size=6,
    num_train_epochs=2,
    gradient_accumulation_steps=16,
    n_gpu=1,
    early_stop_callback=False,
    fp_16=False, 
    opt_level='O1', 
    max_grad_norm=1.0,
    seed=42,
)

tokenizer = T5Tokenizer.from_pretrained('t5-base')

if not os.path.exists('t5_QQP'):
    os.makedirs('t5_QQP')


args_dict.update({'output_dir': 't5_paraphrase','num_train_epochs':3,'max_seq_length':256})
args = argparse.Namespace(**args_dict)
print(args_dict)

train_params = dict(
    accumulate_grad_batches=args.gradient_accumulation_steps,
    gpus=args.n_gpu,
    max_epochs=args.num_train_epochs,
    early_stop_callback=False,
    precision= 16 if args.fp_16 else 32,
    amp_level=args.opt_level,
    gradient_clip_val=args.max_grad_norm,
    callbacks=[LoggingCallback()],
)

model = T5FineTuner(args)

# I will have to debug and add a few things before using this model

"""#CTRL"""

from transformers import CTRLModel, CTRLConfig

!nvidia-smi

!git clone https://github.com/salesforce/ctrl

# Commented out IPython magic to ensure Python compatibility.
# %cd ctrl/

!git checkout lower_memory

!pip2 install tensorflow-gpu==1.14

!patch -b /usr/local/lib/python2.7/dist-packages/tensorflow_estimator/python/estimator/keras.py estimator.patch

!pip2 install fastBPE

!pip2 install gsutil

!gsutil -m cp -r gs://sf-ctrl/seqlen256_v1.ckpt .

!python2 generation.py --model seqlen256_v1.ckpt/model.ckpt-413000.data-00000-of-00001 --print_once

# Commented out IPython magic to ensure Python compatibility.
# %load_ext autoreload
# %autoreload 2

"""# Key to Text"""

!pip install keytotext --upgrade

from keytotext import pipeline

nlp = pipeline("k2t")

nlp

nlp(['why','you','want','my','email','address'])

nlp = pipeline("mrm8488/t5-base-finetuned-common_gen")

nlp(['why','do','you','want','my','email'])

nlp(['why','want','my','email'])

nlp(['why','you','want','my','email'])

# if we further extend this model to include the questions as well, this
# can generate pretty good results



"""# Pegasus"""

!pip install transformers

import torch
from transformers import PegasusForConditionalGeneration, PegasusTokenizer

model_name = 'tuner007/pegasus_paraphrase'
torch_device = 'cuda' if torch.cuda.is_available() else 'cpu'

!pip install sentencepiece

tokenizer = PegasusTokenizer.from_pretrained(model_name)

model = PegasusForConditionalGeneration.from_pretrained(model_name).to(torch_device)

def get_response(input_text,num_return_sequences,num_beams,temperature=1.5):
  batch = tokenizer([input_text],truncation=True,padding='longest',max_length=60, return_tensors="pt").to(torch_device)
  translated = model.generate(**batch,max_length=60,num_beams=num_beams, 
                              num_return_sequences=num_return_sequences, temperature=temperature)
  tgt_text = tokenizer.batch_decode(translated, skip_special_tokens=True)
  return tgt_text

get_response('Why do you want my email address',10,10)

# let's decrease the temperature
get_response('Why do you want my email address',10,10,0.1)

# let's increase the temperature
get_response('Why do you want my email address',10,10,3.0)

# temperature is not affecting the output as seen above

# let's increase the beam length
get_response('Why do you want my email address',10,100)

# increasing beam length in this case
# will only yield good results when the sequences returned are pretty close to the beam length

get_response('Why do you want my email address?',50,50)

# staring a chain or a tree
get_response("I don't understand why you want my email address",10,10)

get_response("I am not sure why you want my email address",10,10)

get_response("Why is my email address important to you",10,10)

# like this, we can generate a lot of paraphrased sentences. This process of creating chains can be 
# automated. I have done it manually, just for demonstration.

"""# Parrot"""

!pip install parrot

!pip install git+https://github.com/PrithivirajDamodaran/Parrot_Paraphraser.git

from parrot import Parrot
import torch
import warnings
warnings.filterwarnings("ignore")

parrot = Parrot(model_tag="prithivida/parrot_paraphraser_on_T5", use_gpu=False)

phrase = 'Why do you want my email address?'
para_phrases = parrot.augment(input_phrase=phrase, 
                               diversity_ranker="levenshtein",
                               do_diverse=True, 
                               max_return_phrases = 10, 
                               max_length=32, 
                               adequacy_threshold = 0.99, 
                               fluency_threshold = 0.90)

for para_phrase in para_phrases:
   print(para_phrase)

# setting the diversity to false.
# for example

para_phrases = parrot.augment(input_phrase=phrase, 
                               diversity_ranker="levenshtein",
                               do_diverse=False, 
                               max_return_phrases = 10, 
                               max_length=32, 
                               adequacy_threshold = 0.99, 
                               fluency_threshold = 0.90)

for para_phrase in para_phrases:
   print(para_phrase)

# decreasing the fluency and adequecy

para_phrases = parrot.augment(input_phrase=phrase, 
                               diversity_ranker="levenshtein",
                               do_diverse=True, 
                               max_return_phrases = 10, 
                               max_length=64, 
                               adequacy_threshold = 0.70, 
                               fluency_threshold = 0.75)

for para_phrase in para_phrases:
   print(para_phrase)

# Decreasing fluency and adequecy don't produce any good results.
# It is clear from the name of parameters as well. So, to have good results, it might be better to set a good fluency
# so that the parapharase makes sense, and also the adequecy to force the model to stick to the original intent

"""# Pegasus & Parrot (Functional Implementation)

### Pegasus
"""

!pip install transformers
!pip install sentencepiece

import torch
from transformers import PegasusForConditionalGeneration, PegasusTokenizer
import math
import pandas as pd

model_name = 'tuner007/pegasus_paraphrase'
torch_device = 'cuda' if torch.cuda.is_available() else 'cpu'
tokenizer_pegasus = PegasusTokenizer.from_pretrained(model_name)
model_pegasus = PegasusForConditionalGeneration.from_pretrained(model_name).to(torch_device)

"""#### Functions to create Chain and get Reponse"""

# Using recursion to implement chaining. Creating a Breadth-First tree-like structure.

def chain(sentence, hyperParameters, num, default, paraphrased, stack):
    if len(paraphrased)<num:
      batch = tokenizer_pegasus([sentence],truncation=True,padding='longest',max_length=60, return_tensors="pt").to(torch_device)

      translated = model_pegasus.generate(**batch,max_length=60,num_beams=hyperParameters['num_beams'], 
                                      num_return_sequences=default, temperature=hyperParameters['temperature'])
      tgt_text = tokenizer_pegasus.batch_decode(translated, skip_special_tokens=True)

      for sentence in tgt_text:
          if sentence not in paraphrased:
            paraphrased.append(sentence)
    if(len(paraphrased)<num):
      for sentence in paraphrased:
        if(sentence not in stack):
          stack.append(sentence)
          chain(sentence, hyperParameters, num, default, paraphrased, stack)


def get_response(sentences,hyperParameters,chaining, num_phrases):
  '''
  Parameters:-
    sentences: list of tuples. [(sentence, intent),....]
    hyperParameters: Dictionary of hyper-parameters. {num_beams, temperature}
    chaining: Boolean specifying whether to use chaining or not.
    num_phrases: integer number specifying the number of phrases to generate for each input sentence. 4
  '''
  output = []
  for (sentence,intent) in sentences:
    print(sentence)
    paraphrased = [] # To store the paraphrased sentences
    if(chaining):
      num = num_phrases
      default = min(5, num_phrases); # Default number of phrases for each output call
      hyperParameters['num_beams'] = default # as beam length should be equal or greater than
      stack = []                             # number of sequences(default) 
      # Implemented chain using recursion
      chain(sentence,hyperParameters,num,default,paraphrased,stack)
      paraphrased = paraphrased[:num_phrases]

    else:
      batch = tokenizer_pegasus([sentence],truncation=True,padding='longest',max_length=60, return_tensors="pt").to(torch_device)
      translated = model_pegasus.generate(**batch,max_length=60,num_beams=hyperParameters['num_beams'], 
                                  num_return_sequences=num_phrases, temperature=hyperParameters['temperature'])     
      paraphrased += tokenizer_pegasus.batch_decode(translated, skip_special_tokens=True)
    
    output.append((paraphrased,intent))

  return output

"""#### Function to save the data as a CSV"""

def createCSV(paraphrases_list, path, name_of_the_file):
  '''
  Parameters:-
    paraphrases_list: output of the get_response function
    path: path where the csv file should be stored
    name_of_the_file: name  of the output csv file

  '''
  data = {'sentences':[],'labels':[]}
  for paraphrased_type in paraphrases_list:
    rows_para = paraphrased_type[0]
    rows_type = paraphrased_type[1]
    data['sentences'] += rows_para
    data['labels'] += [rows_type]*len(paraphrased_type[0])

  dataFrame = pd.DataFrame(data, columns=['sentences','labels'])
  dataFrame.to_csv(path+'/'+name_of_the_file)
  return dataFrame

"""#### Hyper-Parameters Explanation

**About Pegasus:-**
Pegasus was originally trained for Abstractive Summarization. During pre-training, instead of predicting masked words or tokens, the model was presented with the challenge to predict the masked sentences. This way, it differes from other Transformer models because Pegasus was pretrained using sentence masking rather than words. Pegasus is based on a transformer encoder-decoder model.

![image.png](data:image/png;base64,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)


-------------------------------------------------------------
**Hyper-parameters:-**

**->Temperature:** Same as explained in DialoGPT. 

For reference: Temperature sampling is implemented by dividing logits by the temperature value before feeding them into softmax. Temperature greater than 1 generally decreases the confidence while lower temperature makes the model increasingly confident in its top choices. Therefore, we have to find a balance for the value of temperature. If we decrease the temperature too much, the model will become too confident in its top choices and will result in genetating the same answer again and again. On the other hand, if we increase the temperature too much, it will start diverting from the original intent. A value of `1.5` was wound to be perfect for our case (The value was choosen after testing multiple values.)

**!!Note:** For pegasus, changing the temperature didn't seem to make any difference. I tried many values of temperature and generated 100 sentences for each value of temperature (without chaining) but it wasn't even able to generate 5 unique sentences (sentences that are not contained in the output for some other temperature value). Every temperature value generated almost the same sentences.

--------------------------------------------------------------
**-> num_beams**: A parameter for beam search decoder.The beam search algorithm selects multiple alternatives for an input sequence at each timestep based on conditional probability. The number of multiple alternatives depends on a parameter called Beam Width B or `num_beams` in this case. At each time step, the beam search selects B number of best alternatives with the highest probability as the most likely possible choices for the time step.

#### Testing

Define the parameters here.
"""

sentences = [('Why do you want my email address?','user_asks_why'),
             ('my email address is james@gmail.com','user_provides_email')]

chaining = False
num_phrases = 100  # Number of phrases to be generated for each input sentence
                   # Note, num phrases should be equal or less than the beam length when chain == false

# Define the hyperparameters
hyperParameters = {'num_beams':100,'temperature':1.5}

# Path where the csv file will be stored
path = '/content'

# Name of the csv file
name_of_the_file = 'paraphrased_sentences_pegasus.csv'

"""!! Execute the below cell to generate responses and then save them in a csv file."""

out = createCSV(get_response(sentences,hyperParameters,chaining, num_phrases),
                path,name_of_the_file)

# Kindly, Ignore this cell
sentences = [('Do you mind providing your email address?','user_confirms_if')]
get_response(sentences,hyperParameters,chaining, num_phrases)

# with Chaining
chaining = True
name_of_the_file = 'paraphrased_sentences_pegasus_2.csv'

out = createCSV(get_response(sentences,hyperParameters,chaining, num_phrases),
                path,name_of_the_file)

out

"""### Parrot"""

!pip install parrot
!pip install git+https://github.com/PrithivirajDamodaran/Parrot_Paraphraser.git

from parrot import Parrot
import torch
import warnings
import pandas as pd
warnings.filterwarnings("ignore")

parrot = Parrot(model_tag="prithivida/parrot_paraphraser_on_T5", use_gpu=False)

"""#### Functions to create Chain and get Reponse"""

# Using recursion to implement chaining. Creating a Breadth First tree like structure.

def chain_p(sentence, hyperParameters, num, default, paraphrased, stack):
    if len(paraphrased)<num:
       para_phrases_t = []
       para_phrases  = parrot.augment(input_phrase=sentence, 
                          diversity_ranker="levenshtein",
                          do_diverse=hyperParameters['do_diverse'], 
                          max_return_phrases = default, 
                          max_length=32, 
                          adequacy_threshold = hyperParameters['adequacy_threshold'], 
                          fluency_threshold = hyperParameters['fluency_threshold'])
       para_phrases_t += [para_phrase[0] for para_phrase in para_phrases]
       for sentence in para_phrases_t:
          if sentence not in paraphrased:
            paraphrased.append(sentence)
    if(len(paraphrased)<num):
      for sentence in paraphrased:
        if(sentence not in stack):
          stack.append(sentence)
          chain_p(sentence, hyperParameters, num, default, paraphrased, stack)
          

def get_response_p(sentences,hyperParameters,chaining, num_phrases):
  '''
  Parameters:-
    sentences: list of tuples. [(sentence, intent),....]
    hyperParameters: Dictionary of hyper-parameters. {num_beams, temperature}
    chaining: Boolean specifying whether to use chaining or not.
    num_phrases: integer number specifying the number of phrases to generate for each input sentence. 4
  '''
  output = []
  for (sentence,intent) in sentences:
    print(sentence)
    paraphrased = [] # To store the paraphrased sentences
    if(chaining):
      num = num_phrases
      default = min(5, num_phrases); # Default number of phrases
      stack = []
      # Implemented chain using recursion
      chain_p(sentence,hyperParameters,num,default,paraphrased,stack)
      paraphrased = paraphrased[:num_phrases]

    else:
      para_phrases = parrot.augment(input_phrase=sentence, 
                               diversity_ranker="levenshtein",
                               do_diverse=hyperParameters['do_diverse'], 
                               max_return_phrases = num_phrases, 
                               max_length=32, 
                               adequacy_threshold = hyperParameters['adequacy_threshold'], 
                               fluency_threshold = hyperParameters['fluency_threshold'])
      
      paraphrased += [para_phrase[0] for para_phrase in para_phrases] 

   
    output.append((paraphrased,intent))

  return output

"""#### Function to Store the data as a CSV


"""

# same createCSV function
def createCSV(paraphrases_list, path, name_of_the_file):
  '''
  Parameters:-
    paraphrases_list: output of the get_response function
    path: path where the csv file should be stored
    name_of_the_file: name  of the output csv file

  '''
  data = {'sentences':[],'labels':[]}
  for paraphrased_type in paraphrases_list:
    rows_para = paraphrased_type[0]
    rows_type = paraphrased_type[1]
    data['sentences'] += rows_para
    data['labels'] += [rows_type]*len(paraphrased_type[0])

  dataFrame = pd.DataFrame(data, columns=['sentences','labels'])
  dataFrame.to_csv(path+'/'+name_of_the_file)
  return dataFrame

"""#### Hyper-Parameters Explanation

**About Parrot:-**

Parrot is a paraphrase based utterance augmentation framework. Under the hood, parrot uses the same T-5 model developed by Google. T-5 model was finetuned to generate paraphrases by also including adequecy and fluency thresholds. It proposes that a good paraphrase should be `adequate` and `fluent` while being as different as possible on the surface lexical form. 

With respect to this definition, the 3 key metrics that measures the quality of paraphrases are:

- Adequacy (Is the meaning preserved adequately?)
- Fluency (Is the paraphrase fluent English?)
- Diversity (Lexical / Phrasal / Syntactical) (How much has the paraphrase changed the original sentence?) 

The main aim was to use this model for augmenting data to train NLU based models.

--------------------------------------------------------------
(I had to go into the code to extract the below info because on the GitHub Readme, they don't provide any info about how these hyper-parameters actually work)

**Hyper-Parameters:**

**-> do_diverse:** How much has the paraphrase changed the original sentence? If true, the parrot model will try to create diverse sentences and will try to change the lexical, phrasal and syntactical form of the original sentence but will keep the original intent. There are three diversity rankers the model is using, `levenshtein`, `euclidean`, and `diff`. `levenshtein` works best for every case.

--------------------------------------------------------------
**-> adequacy_threshold**: Is the meaning preserved adequately? As the name suggests, when the value of `adequacy_threshold` is high, the model will be forced to stick to the original intent. If the value is too low, the model will start diverting and the paraphrased sentences won't preserve the original intent of the sentence.

It uses `BART` under the hood to measure the intent similarity between the input sentence and the paraphrased sentence.

--------------------------------------------------------------
**->fluency_threshold:** Is the paraphrase fluent English? As the name suggests, high `fluency_threshold` value will result in more fluent paraphrased sentences. It will make sure that the paraphrased sentence, the model generates, is fluent and doesn't contain any grammatical mistakes.

It uses a simple `BERT` model fine-tuned for fluency score generation to automatically discard the sentences that produces less fluency score than the set threshold.

#### Test

Define and Initialize the parameters here.
"""

sentences = [('Why do you want my email address?','user_asks_why'),
             ('my email address is james@gmail.com','user_provides_email')]

chaining = False
num_phrases = 10  # Number of phrases to be generated for each input sentence

# Define the hyperparameters
hyperParameters = {'do_diverse':True,'adequacy_threshold':0.99,'fluency_threshold':0.90}

# Diversity Rankers are "levenshtein", "euclidean", "diff"

# Path where the csv file will be stored
path = '/content'

# Name of the csv file
name_of_the_file = 'paraphrased_sentences_parrot.csv'

# Testing without saving the output in csv, scroll to the end for that prompt.
get_response_p(sentences,hyperParameters,chaining, num_phrases)

# With Chaining
chaining = True
get_response_p(sentences,hyperParameters,chaining, num_phrases)

# As you can see that parrot model is less powerful than the pegasus model
# Parrot was not even able to generate 10 paraphrased sentences for the first sentence
# But with chaining we were able to generate 10

# For the second sentence parrot was only able to generate one paraphrased sentence,
# chaining also didn't wokr for this case

# To store in a CSV
out = createCSV(get_response_p(sentences,hyperParameters,chaining, num_phrases),
                path,name_of_the_file)

